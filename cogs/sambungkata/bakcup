
import discord
from discord.ext import commands
import asyncio
import random
import re
from typing import Dict, List, Optional, Set
from utils.setup.db import db_connection

class WordChainGame:
    def __init__(self, channel_id: int, host_id: int):
        self.channel_id = channel_id
        self.host_id = host_id
        self.players: List[int] = []  # User IDs
        self.scores: Dict[int, int] = {}  # user_id: score
        self.passes: Dict[int, int] = {}  # user_id: pass_count
        self.rolls: Dict[int, int] = {}  # user_id: roll_count
        self.used_words: Set[str] = set()  # Track used words
        self.current_player_index = 0
        self.current_word = ""
        self.current_suffix = ""
        self.is_active = False
        self.is_joining = True
        self.join_message: Optional[discord.Message] = None
        self.game_message: Optional[discord.Message] = None
        self.turn_timeout_task: Optional[asyncio.Task] = None
        self.join_timeout_task: Optional[asyncio.Task] = None

    def cleanup(self):
        """Clean up all tasks and references"""
        if self.turn_timeout_task and not self.turn_timeout_task.done():
            self.turn_timeout_task.cancel()
        if self.join_timeout_task and not self.join_timeout_task.done():
            self.join_timeout_task.cancel()
        
        self.players.clear()
        self.scores.clear()
        self.passes.clear()
        self.rolls.clear()
        self.used_words.clear()
        self.join_message = None
        self.game_message = None
        self.turn_timeout_task = None
        self.join_timeout_task = None


class JoinGameView(discord.ui.View):
    def __init__(self, cog, game: WordChainGame):
        super().__init__(timeout=120)
        self.cog = cog
        self.game = game

    @discord.ui.button(label="Join", style=discord.ButtonStyle.green, emoji="‚ûï")
    async def join_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id == self.cog.bot.user.id:
            await interaction.response.defer()
            return
            
        if interaction.user.id in self.game.players:
            await interaction.response.send_message("Kamu sudah bergabung!", ephemeral=True)
            return
        
        if len(self.game.players) >= 10:
            await interaction.response.send_message("Game sudah penuh!", ephemeral=True)
            return
        
        self.game.players.append(interaction.user.id)
        self.game.scores[interaction.user.id] = 0
        self.game.passes[interaction.user.id] = 0
        self.game.rolls[interaction.user.id] = 0
        
        embed = self.cog.create_join_embed(self.game)
        await interaction.response.edit_message(embed=embed, view=self)
    
    @discord.ui.button(label="Start", style=discord.ButtonStyle.primary, emoji="‚ñ∂Ô∏è")
    async def start_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.game.host_id:
            await interaction.response.send_message("Hanya host yang bisa memulai game!", ephemeral=True)
            return
        
        if len(self.game.players) < 1:
            await interaction.response.send_message("Minimal 1 pemain untuk memulai!", ephemeral=True)
            return
        
        await self.cog.start_game(self.game, interaction)
    
    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.danger, emoji="‚ùå")
    async def cancel_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.game.host_id:
            await interaction.response.send_message("Hanya host yang bisa membatalkan game!", ephemeral=True)
            return
        
        # Clean up game
        await self.cog.cancel_game(self.game, interaction)

    async def on_timeout(self):
        """Called when view times out"""
        if self.game.is_joining:
            channel = self.cog.bot.get_channel(self.game.channel_id)
            if channel:
                try:
                    await channel.send("‚è∞ Waktu bergabung habis! Game dibatalkan.")
                except:
                    pass
            
            # Clean up
            await self.cog.cleanup_game(self.game.channel_id)


class WordChainCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.games: Dict[int, WordChainGame] = {}  # channel_id: game
        self.message_locks: Dict[int, asyncio.Lock] = {}  # channel_id: lock

    def get_lock(self, channel_id: int) -> asyncio.Lock:
        """Get or create a lock for the channel"""
        if channel_id not in self.message_locks:
            self.message_locks[channel_id] = asyncio.Lock()
        return self.message_locks[channel_id]

    async def cleanup_game(self, channel_id: int):
        """Clean up game and remove from tracking"""
        if channel_id in self.games:
            game = self.games[channel_id]
            game.cleanup()
            del self.games[channel_id]
        
        # Clean up lock as well
        if channel_id in self.message_locks:
            del self.message_locks[channel_id]

    async def cancel_game(self, game: WordChainGame, interaction: discord.Interaction):
        """Cancel the game"""
        embed = discord.Embed(
            title="‚ùå Game Dibatalkan",
            description="Game telah dibatalkan oleh host.",
            color=0xff0000
        )
        await interaction.response.edit_message(embed=embed, view=None)
        await self.cleanup_game(game.channel_id)

    def split_syllables(self, word: str) -> List[str]:
        """Simple syllable splitting for Indonesian words"""
        # Basic Indonesian syllable patterns
        vowels = 'aiueo'
        consonants = 'bcdfghjklmnpqrstvwxyz'
        
        word = word.lower()
        syllables = []
        current = ""
        
        i = 0
        while i < len(word):
            current += word[i]
            
            # If current char is vowel and next is consonant
            if i < len(word) - 1:
                if word[i] in vowels and word[i + 1] in consonants:
                    # Check if there's another vowel after consonant
                    if i < len(word) - 2 and word[i + 2] in vowels:
                        syllables.append(current)
                        current = ""
            i += 1
        
        if current:
            syllables.append(current)
        
        return syllables if len(syllables) > 1 else []

    def get_smart_suffix(self, word: str) -> str:
        """Get smart suffix with max 3 characters"""
        word = word.lower()
        
        # Try syllable splitting first
        syllables = self.split_syllables(word)
        
        if syllables and len(syllables) > 1:
            # Use last syllable, but max 3 chars
            last_syllable = syllables[-1]
            if len(last_syllable) <= 3:
                return last_syllable
            else:
                # If syllable too long, take last 2-3 chars
                return last_syllable[-random.choice([2, 3]):]
        else:
            # Fallback: random 2 or 3 characters from end, max 3
            if len(word) >= 3:
                return word[-random.choice([2, 3]):]
            elif len(word) >= 2:
                return word[-2:]
            else:
                return word[-1:]

    async def get_random_word(self) -> Optional[str]:
        """Get a random word from database (no spaces allowed)"""
        async with db_connection(self.bot) as conn:
            try:
                # Get random ID first, but exclude words with spaces
                max_id_result = await conn.fetchrow("SELECT MAX(_id) as max_id FROM dictionary WHERE word NOT LIKE '% %'")
                if not max_id_result or not max_id_result['max_id']:
                    return None
                
                max_attempts = 50
                for _ in range(max_attempts):
                    random_id = random.randint(1, max_id_result['max_id'])
                    result = await conn.fetchrow(
                        "SELECT word FROM dictionary WHERE _id = $1 AND word NOT LIKE '% %'", 
                        random_id
                    )
                    if result:
                        word = result['word'].lower().strip()
                        # Double check no spaces
                        if ' ' not in word:
                            return word
                
                # Fallback: get any word without spaces
                result = await conn.fetchrow(
                    "SELECT word FROM dictionary WHERE word NOT LIKE '% %' ORDER BY RANDOM() LIMIT 1"
                )
                if result:
                    word = result['word'].lower().strip()
                    return word if ' ' not in word else None
                return None
            except Exception as e:
                print(f"Database error in get_random_word: {e}")
                return None

    async def validate_word(self, word: str) -> bool:
        """Check if word exists in database (no spaces allowed)"""
        async with db_connection(self.bot) as conn:
            try:
                # First check if word contains spaces
                clean_word = word.lower().strip()
                if ' ' in clean_word:
                    return False
                
                result = await conn.fetchrow(
                    "SELECT 1 FROM dictionary WHERE LOWER(word) = $1 AND word NOT LIKE '% %'", 
                    clean_word
                )
                return result is not None
            except Exception as e:
                print(f"Database error in validate_word: {e}")
                return False

    def create_join_embed(self, game: WordChainGame) -> discord.Embed:
        """Create embed for join phase"""
        embed = discord.Embed(
            title="Sambung Kata",
            description="Klik tombol **Join** untuk bergabung!\nHost dapat menekan **Start** untuk memulai game.",
            color=0x00ff00
        )
        
        if game.players:
            player_mentions = [f"<@{player_id}>" for player_id in game.players]
            embed.add_field(
                name=f"Pemain ({len(game.players)}/10)",
                value="\n".join(player_mentions),
                inline=False
            )
        else:
            embed.add_field(name="Pemain (0/10)", value="Belum ada pemain", inline=False)
        
        embed.add_field(name="Host", value=f"<@{game.host_id}>", inline=True)
        embed.set_footer(text="Waktu bergabung: 2 menit")
        return embed

    def create_game_embed(self, game: WordChainGame) -> discord.Embed:
        """Create embed for active game"""
        embed = discord.Embed(
            title="Sambung Kata",
            color=0xff9900
        )
        
        if game.current_word:
            embed.add_field(
                name="Kata :",
                value=f"```{game.current_word}```",
                inline=False
            )
            embed.add_field(
                name="Lanjutkan dengan awalan :",
                value=f"`{game.current_suffix}`",
                inline=False
            )
        
        if game.players:
            current_player = game.players[game.current_player_index]
            if current_player == self.bot.user.id:
                embed.add_field(
                    name="Giliran",
                    value=f"<@{self.bot.user.id}>",
                    inline=True
                )
            else:
                embed.add_field(
                    name="Giliran",
                    value=f"<@{current_player}>",
                    inline=True
                )
        
        # Show scores with turn indicator
        if game.scores:
            score_text = []
            for i, player_id in enumerate(game.players):
                if player_id in game.scores:
                    
                    if player_id == self.bot.user.id:
                        score_text.append(f"<@{self.bot.user.id}>: {game.scores[player_id]} poin")
                    else:
                        score_text.append(f"<@{player_id}>: {game.scores[player_id]} poin")
            
            if score_text:
                embed.add_field(
                    name="Skor",
                    value="\n".join(score_text),
                    inline=False
                )
        
        # Show used words count
        if game.used_words:
            embed.add_field(
                name="Kata digunakan :",
                value=f"{len(game.used_words)} kata",
                inline=True
            )
        
        embed.set_footer(text="Ketik 'pass' untuk skip atau 'roll' untuk kata baru")
        return embed

    async def get_bot_word(self, game: WordChainGame) -> Optional[str]:
        """Get a valid word for bot turn (no spaces allowed)"""
        async with db_connection(self.bot) as conn:
            try:
                prefix = game.current_suffix.lower()
                used_words_list = list(game.used_words)
                
                if used_words_list:
                    placeholders = ','.join([f'${i+2}' for i in range(len(used_words_list))])
                    query = f"""
                        SELECT word FROM dictionary 
                        WHERE LOWER(word) LIKE $1 
                        AND word NOT LIKE '% %' 
                        AND LOWER(word) NOT IN ({placeholders}) 
                        ORDER BY RANDOM() LIMIT 1
                    """
                    result = await conn.fetchrow(query, f"{prefix}%", *used_words_list)
                else:
                    result = await conn.fetchrow(
                        """SELECT word FROM dictionary 
                           WHERE LOWER(word) LIKE $1 AND word NOT LIKE '% %' 
                           ORDER BY RANDOM() LIMIT 1""",
                        f"{prefix}%"
                    )
                
                if result:
                    word = result['word'].lower().strip()
                    # Double check no spaces
                    return word if ' ' not in word else None
                return None
            except Exception as e:
                print(f"Database error in get_bot_word: {e}")
                return None

    async def handle_bot_turn(self, game: WordChainGame):
        """Handle bot's turn"""
        if not game.is_active:
            return
        
        channel = self.bot.get_channel(game.channel_id)
        if not channel:
            await self.cleanup_game(game.channel_id)
            return
        
        # Send processing message
        processing_msg = await channel.send("_Processing..._")
        
        await asyncio.sleep(1)
        
        # Try to get a valid word
        bot_word = await self.get_bot_word(game)
        
        if bot_word and bot_word not in game.used_words:
            # Bot found a word
            game.current_word = bot_word
            game.current_suffix = self.get_smart_suffix(bot_word)
            game.used_words.add(bot_word)
            
            # Add score to bot
            game.scores[self.bot.user.id] = game.scores.get(self.bot.user.id, 0) + len(bot_word)
            
            try:
                await processing_msg.edit(content=f"{bot_word}")
            except:
                pass
            
            # Next player
            game.current_player_index = (game.current_player_index + 1) % len(game.players)
            
            # Update embed by deleting old and sending new
            await self.update_game_message(game)
            
            # Continue game
            if game.players[game.current_player_index] == self.bot.user.id:
                await self.handle_bot_turn(game)
            else:
                await self.start_turn_timeout(game)
        
        else:
            # Bot tries to roll first if available
            current_rolls = game.rolls.get(self.bot.user.id, 0)
            
            try:
                await processing_msg.delete()
            except:
                pass
            
            if current_rolls < 2:
                # Bot rolls for new word
                await self.handle_roll(game, self.bot.user.id, is_bot=True)
                return
            
            # Bot passes if no rolls left
            current_passes = game.passes.get(self.bot.user.id, 0)
            
            if current_passes >= 3:
                try:
                    await channel.send(f"<@{self.bot.user.id}> sudah menggunakan seluruh `pass!`")
                except:
                    pass
                await self.eliminate_player(game, self.bot.user.id, "kehabisan `pass`")
                return
            
            game.passes[self.bot.user.id] = current_passes + 1
            try:
                await channel.send(f"<@{self.bot.user.id}> pass! ({current_passes + 1}/3)")
            except:
                pass
            
            # Next player
            game.current_player_index = (game.current_player_index + 1) % len(game.players)
            
            # Update embed
            await self.update_game_message(game)
            
            # Continue game
            if game.players[game.current_player_index] == self.bot.user.id:
                await self.handle_bot_turn(game)
            else:
                await self.start_turn_timeout(game)

    async def handle_roll(self, game: WordChainGame, player_id: int, is_bot: bool = False):
        """Handle roll action to get new word"""
        current_rolls = game.rolls.get(player_id, 0)
        
        if current_rolls >= 2:
            channel = self.bot.get_channel(game.channel_id)
            if channel:
                try:
                    if is_bot:
                        await channel.send(f"<@{self.bot.user.id}> sudah menggunakan seluruh `roll!`")
                    else:
                        await channel.send(f"<@{player_id}> sudah menggunakan seluruh `roll!`")
                except:
                    pass
            return
        
        # Get new random word
        new_word = await self.get_random_word()
        if not new_word:
            return
        
        # Update game state
        game.current_word = new_word
        game.current_suffix = self.get_smart_suffix(new_word)
        game.used_words.add(new_word)
        game.rolls[player_id] = current_rolls + 1
        
        channel = self.bot.get_channel(game.channel_id)
        if channel:
            try:
                if is_bot:
                    await channel.send(f"üé≤ <@{self.bot.user.id}> roll! Kata baru: **{new_word}** ({current_rolls + 1}/2)")
                else:
                    await channel.send(f"üé≤ <@{player_id}> roll! Kata baru: **{new_word}** ({current_rolls + 1}/2)")
            except:
                pass
        
        # Continue with same player (they get to answer the new word)
        await self.update_game_message(game)
        
        if is_bot:
            await self.handle_bot_turn(game)
        else:
            await self.start_turn_timeout(game)

    async def update_game_message(self, game: WordChainGame):
        """Update game message by deleting old and sending new"""
        if game.game_message:
            try:
                await game.game_message.delete()
            except:
                pass
        
        channel = self.bot.get_channel(game.channel_id)
        if channel:
            embed = self.create_game_embed(game)
            try:
                game.game_message = await channel.send(embed=embed)
            except:
                pass

    async def start_game(self, game: WordChainGame, interaction: discord.Interaction):
        """Start the word chain game"""
        game.is_joining = False
        game.is_active = True
        
        # Cancel join timeout
        if game.join_timeout_task and not game.join_timeout_task.done():
            game.join_timeout_task.cancel()
        
        # Check if solo player - add bot as player
        if len(game.players) == 1:
            game.players.append(self.bot.user.id)
            game.scores[self.bot.user.id] = 0
            game.passes[self.bot.user.id] = 0
            game.rolls[self.bot.user.id] = 0
        
        # Get starting word
        starting_word = await self.get_random_word()
        if not starting_word:
            await interaction.response.send_message("Error: Tidak bisa mendapatkan kata dari database!", ephemeral=True)
            await self.cleanup_game(game.channel_id)
            return
        
        game.current_word = starting_word
        game.current_suffix = self.get_smart_suffix(starting_word)
        game.used_words.add(starting_word)
        game.current_player_index = random.randint(0, len(game.players) - 1)
        
        embed = self.create_game_embed(game)
        await interaction.response.edit_message(embed=embed, view=None)
        
        try:
            game.game_message = await interaction.original_response()
        except:
            # Fallback if we can't get original response
            game.game_message = await interaction.followup.send(embed=embed)
        
        # Start turn timeout or bot turn
        if game.players[game.current_player_index] == self.bot.user.id:
            await self.handle_bot_turn(game)
        else:
            await self.start_turn_timeout(game)

    async def start_turn_timeout(self, game: WordChainGame):
        """Start timeout for current player's turn"""
        if game.turn_timeout_task and not game.turn_timeout_task.done():
            game.turn_timeout_task.cancel()
        
        game.turn_timeout_task = asyncio.create_task(self.turn_timeout_handler(game))

    async def turn_timeout_handler(self, game: WordChainGame):
        """Handle turn timeout"""
        try:
            await asyncio.sleep(30)
            if game.is_active and game.players:
                current_player = game.players[game.current_player_index]
                await self.eliminate_player(game, current_player, "waktu habis")
        except asyncio.CancelledError:
            pass

                    
    async def eliminate_player(self, game: WordChainGame, player_id: int, reason: str):
            """Eliminate a player from the game"""
            
            # Pastikan pemain ada di daftar sebelum melanjutkan
            if player_id not in game.players:
                return
            
            # Dapatkan indeks pemain yang akan dieliminasi
            try:
                eliminated_index = game.players.index(player_id)
            except ValueError:
                # Jika pemain tidak ditemukan (meski sudah dicek), keluar
                return
            
            # Hapus pemain dari daftar
            game.players.remove(player_id)
            
            # Sampaikan ke channel
            channel = self.bot.get_channel(game.channel_id)
            if channel:
                try:
                    # Periksa apakah pemain yang dieliminasi adalah bot
                    if player_id == self.bot.user.id:
                        await channel.send(f"<@{self.bot.user.id}> dieliminasi karena **{reason}**!")
                    else:
                        await channel.send(f"<@{player_id}> dieliminasi karena **{reason}**!")
                except:
                    pass
            
            # Periksa kondisi akhir game
            if len(game.players) <= 1:
                await self.end_game(game)
            elif game.players:
                # Atur ulang indeks pemain saat ini.
                # Indeks baru akan menjadi posisi pemain berikutnya
                # (setelah pemain saat ini dihapus), yang dilingkari
                # menggunakan operator modulo.
                game.current_player_index = eliminated_index % len(game.players)
                
                await self.update_game_message(game)
                
                # Lanjutkan dengan pemain berikutnya
                if game.players[game.current_player_index] == self.bot.user.id:
                    await self.handle_bot_turn(game)
                else:
                    await self.start_turn_timeout(game)

    async def end_game(self, game: WordChainGame):
        """End the game and show results"""
        game.is_active = False
        
        if game.turn_timeout_task and not game.turn_timeout_task.done():
            game.turn_timeout_task.cancel()
        
        channel = self.bot.get_channel(game.channel_id)
        if not channel:
            await self.cleanup_game(game.channel_id)
            return
        
        embed = discord.Embed(title="üèÜ Game Selesai!", color=0xffd700)
        
        if game.players:
            winner_id = game.players[0]
            winner_score = game.scores.get(winner_id, 0)
            
            # Check if winner is bot or human
            if winner_id == self.bot.user.id:
                embed.description = f"Pemenang: <@{self.bot.user.id}>\nSkor: {winner_score} poin"
            else:
                embed.description = f"Pemenang: <@{winner_id}>\nSkor: {winner_score} poin"
        else:
            embed.description = "Tidak ada pemenang!"
            embed.color = 0x808080
        
        # Show final scores
        if len(game.scores) > 1:
            sorted_scores = sorted(game.scores.items(), key=lambda x: x[1], reverse=True)
            score_text = []
            for i, (player_id, score) in enumerate(sorted_scores[:5], 1):
                if player_id == self.bot.user.id:
                    score_text.append(f"{i}. <@{self.bot.user.id}>: {score} poin")
                else:
                    score_text.append(f"{i}. <@{player_id}>: {score} poin")
            
            embed.add_field(name="Papan Skor", value="\n".join(score_text), inline=False)
        
        # Show game stats
        embed.add_field(name="Total Kata Terpakai", value=f"{len(game.used_words)}", inline=True)
        
        try:
            await channel.send(embed=embed)
        except:
            pass
        
        # Clean up
        await self.cleanup_game(game.channel_id)
        
    @commands.hybrid_command(name="sambungkata", aliases=["sk"], description="Mulai permainan Sambung Kata")
    async def word_chain(self, ctx: commands.Context):
        """Start a word chain game"""
        channel_id = ctx.channel.id
        
        if channel_id in self.games:
            await ctx.send("Sudah ada game yang sedang berlangsung di channel ini!")
            return
        
        game = WordChainGame(channel_id, ctx.author.id)
        self.games[channel_id] = game
        
        embed = self.create_join_embed(game)
        view = JoinGameView(self, game)
        
        try:
            message = await ctx.send(embed=embed, view=view)
            game.join_message = message
        except Exception as e:
            print(f"Error sending message: {e}")
            await self.cleanup_game(channel_id)
            await ctx.send("Terjadi error saat membuat game!")
            return

    @commands.Cog.listener()
    async def on_message(self, message):
        """Handle game messages"""
        if message.author.bot:
            return
        
        channel_id = message.channel.id
        if channel_id not in self.games:
            return
        
        game = self.games[channel_id]
        if not game.is_active:
            return
        
        async with self.get_lock(channel_id):
            await self._handle_game_message(message, game)

    async def _handle_game_message(self, message, game):
        """Handle game message with lock protection"""
        if not game.players or message.author.id != game.players[game.current_player_index]:
            return
        
        content = message.content.lower().strip()
        
        # Handle pass
        if content == "pass":
            player_id = message.author.id
            current_passes = game.passes.get(player_id, 0)
            
            if current_passes >= 3:
                try:
                    await message.channel.send(f"<@{player_id}> sudah menggunakan semua pass!")
                except:
                    pass
                await self.eliminate_player(game, player_id, "kehabisan pass")
                return
            
            game.passes[player_id] = current_passes + 1
            
            try:
                await message.channel.send(f"<@{player_id}> pass! ({current_passes + 1}/3)")
            except:
                pass
            
            # Next player
            game.current_player_index = (game.current_player_index + 1) % len(game.players)
            
            await self.update_game_message(game)
            
            # Continue with next player
            if game.players[game.current_player_index] == self.bot.user.id:
                await self.handle_bot_turn(game)
            else:
                await self.start_turn_timeout(game)
            return
        
        # Handle roll
        if content == "roll":
            await self.handle_roll(game, message.author.id)
            return
        
        # Validate word format
        if not content.isalpha():
            return
        
        # Check if word was already used
        if content in game.used_words:
            try:
                await message.channel.send(f"'{content}' sudah digunakan!")
            except:
                pass
            return
        
        # Check if word starts with required suffix
        if not content.startswith(game.current_suffix.lower()):
            try:
                await message.channel.send(f"Harus dimulai dengan `{game.current_suffix}`!")
            except:
                pass
            return
        
        # Validate word in database
        if not await self.validate_word(content):
            try:
                await message.channel.send("Kata tidak ditemukan!")
            except:
                pass
            return
        
        # Cancel timeout
        if game.turn_timeout_task and not game.turn_timeout_task.done():
            game.turn_timeout_task.cancel()
        
        # Update game state
        game.current_word = content
        game.current_suffix = self.get_smart_suffix(content)
        game.used_words.add(content)
        
        # Add score
        player_id = message.author.id
        game.scores[player_id] = game.scores.get(player_id, 0) + len(content)
        
        # Next player
        game.current_player_index = (game.current_player_index + 1) % len(game.players)
        
        # Update embed
        await self.update_game_message(game)
        
        # Start next turn
        if game.players[game.current_player_index] == self.bot.user.id:
            await self.handle_bot_turn(game)
        else:
            await self.start_turn_timeout(game)

    def cog_unload(self):
        """Clean up when cog is unloaded"""
        for channel_id in list(self.games.keys()):
            asyncio.create_task(self.cleanup_game(channel_id))


async def setup(bot):
    await bot.add_cog(WordChainCog(bot))