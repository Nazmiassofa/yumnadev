import asyncio
import logging
import random

from discord.ext import commands
from discord import Embed, ui, ButtonStyle, Interaction
from .database.db import DataBaseManager as db
from utils.data.emot import (JOIN,
                             START,
                             WINNER,
                             PRIZE,
                             WRONG,
                             CORRECT,
                             SKULL,
                             SKULLHEART,
                             PLANNER,
                             TIMEOUT,
                             REDHEART,
                             POINT,
                             CHAT,
                             DICE,
                             PROGRESS,
                             WARNING)


logger = logging.getLogger(__name__)

class JoinView(ui.View):
    def __init__(self, cog, ctx):
        super().__init__(timeout=60)
        self.cog = cog
        self.ctx = ctx
        self.message = None

    @ui.button(label="Join", style=ButtonStyle.secondary, custom_id="hangman_join", emoji=f"{JOIN}")
    async def join_button(self, interaction: Interaction, button: ui.Button):
        game = self.cog.games.get(self.ctx.channel.id)
        user = interaction.user
        
        if not game or game['phase'] != 'join':
            return await interaction.response.send_message("❗ Tidak ada fase join aktif.", ephemeral=True)

        if user.id in game['players']:
            return await interaction.response.send_message(f"{WARNING} Kamu sudah bergabung dalam game ini.", ephemeral=True)
        
        if len(game['players']) >= 5:
            return await interaction.response.send_message("❗ Slot pemain sudah penuh (maksimal 5 pemain).", ephemeral=True)

        game['players'][user.id] = {'member': user, 'health': 5, 'points': 0, 'correct_guesses': 0}
        
        # Update embed
        embed = self.message.embeds[0]
        names = [p['member'].display_name for p in game['players'].values()]
        embed.description = (
            f"{SKULL} **Pemain yang bergabung:**\n"
            + "\n".join(f"`{i+1}.` {n}" for i, n in enumerate(names))
            + f"\n\n{PLANNER} **Pemain**: {len(names)}/5"
        )
        embed.color = 0x3498db if len(names) < 5 else 0x2ecc71
        await interaction.response.edit_message(embed=embed, view=self)

    @ui.button(label="Start Game", style=ButtonStyle.success, custom_id="hangman_start", emoji=f"{START}")
    async def start_button(self, interaction: Interaction, button: ui.Button):
        game = self.cog.games.get(self.ctx.channel.id)
        if not game or game['phase'] != 'join':
            return await interaction.response.send_message("❗ Tidak ada fase join aktif.", ephemeral=True)
        
        if interaction.user != game['host']:
            return await interaction.response.send_message(f"{WARNING} Hanya host yang dapat memulai game.", ephemeral=True)
        
        if len(game['players']) < 1:
            return await interaction.response.send_message(f"{WARNING} Minimal 1 pemain untuk memulai game.", ephemeral=True)

        game['phase'] = 'starting'
        self.stop()
        
        # Show starting message with countdown
        embed = Embed(
            title=f"{START} Game Dimulai!",
            description="Mempersiapkan game hangman...",
            color=0xf39c12
        )
        await interaction.response.edit_message(embed=embed, view=None)
        
        # Small delay for better UX
        await asyncio.sleep(1)
        await self.cog._begin_game(self.ctx, game)

    @ui.button(label="Cancel", style=ButtonStyle.danger, custom_id="hangman_cancel", emoji="❌")
    async def cancel_button(self, interaction: Interaction, button: ui.Button):
        game = self.cog.games.get(self.ctx.channel.id)
        if not game or game['phase'] != 'join':
            return await interaction.response.send_message("❗ Game sudah tidak aktif.", ephemeral=True)
        
        if interaction.user != game['host']:
            return await interaction.response.send_message(f"{WARNING} Hanya host yang dapat membatalkan game.", ephemeral=True)
        
        del self.cog.games[self.ctx.channel.id]
        self.stop()
        
        embed = Embed(
            title="❌ Game Dibatalkan",
            description="Game hangman telah dibatalkan oleh host.",
            color=0xe74c3c
        )
        await interaction.response.edit_message(embed=embed, view=None)

class HangmanCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.games: dict[int, dict] = {}

    @commands.command(name="hangman", aliases=["hm"])
    async def start_join(self, ctx: commands.Context):
        """Memulai game Hangman baru dengan fase join menggunakan tombol UI."""
        cid = ctx.channel.id
        if cid in self.games:
            return await ctx.send("❗ Sudah ada game Hangman aktif di channel ini. \n-#Tunggu hingga selesai atau minta host untuk membatalkan.")

        # Setup game state
        self.games[cid] = {
            'host': ctx.author,
            'phase': 'join',
            'word': None,
            'clue': None,
            'display': None,
            'letters_left': 0,
            'players': {},
            'guessed': set(),
            'is_solo': False,
            'round_number': 1
        }
        
        embed = Embed(
            title=f"{START} Hangman - Join Phase", 
            color=0x3498db
        )
        embed.add_field(
            name=f"{PLANNER} Aturan Game", 
            value=(
                "• Tebak huruf satu per satu atau langsung tebak kata\n"
                "• Setiap salah tebak mengurangi 1 nyawa\n"
                "• Setiap benar menebak huruf +1 poin\n"
                "• Menebak kata lengkap +3 poin"
            ), 
            inline=False
        )
        embed.set_footer(text=f"Host: {ctx.author.display_name} | Timeout: 60 detik")

        view = JoinView(self, ctx)
        message = await ctx.send(embed=embed, view=view)
        view.message = message

        # Timeout handler
        await view.wait()
        game = self.games.get(cid)
        if game and game['phase'] == 'join':
            embed = Embed(
                title=f"{TIMEOUT} Waktu Habis", 
                description="Fase join telah berakhir. Game dibatalkan.",
                color=0x95a5a6
            )
            await message.edit(embed=embed, view=None)
            del self.games[cid]

    async def _begin_game(self, ctx: commands.Context, game: dict):
        cid = ctx.channel.id
        word, clue = await db.getter_word(self)
        if not word:
            embed = Embed(
                title="❌ Error",
                description="Gagal mengambil kata dari database. Game dibatalkan.",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)
            if cid in self.games:
                del self.games[cid]
            return
        
        # Handle clue kosong
        if not clue or clue.strip() == "":
            clue = "🤔 Tidak ada petunjuk tersedia"

        word = word.lower().strip()
        display = ['_' if char.isalpha() else char for char in word]
        letters_left = len(set(char for char in word if char.isalpha()))
        
        # Determine if solo game
        is_solo = len(game['players']) == 1
        game['is_solo'] = is_solo
        
        # Beri petunjuk huruf acak untuk kata panjang
        revealed_count = 0
        if len(word) > 6:
            # Dapatkan semua index huruf yang bisa di-reveal (bukan spasi/simbol)
            revealable_indices = [i for i, char in enumerate(word) if char.isalpha()]
            
            # Tentukan jumlah huruf yang akan di-reveal
            num_to_reveal = 1 if len(word) <= 8 else 2
            
            # Pilih huruf acak
            if revealable_indices:
                random_indices = random.sample(revealable_indices, min(num_to_reveal, len(revealable_indices)))
                
                revealed_letters = set()
                for idx in random_indices:
                    letter = word[idx]
                    if letter not in revealed_letters:
                        revealed_letters.add(letter)
                        # Reveal all instances of this letter
                        for i, char in enumerate(word):
                            if char == letter:
                                display[i] = letter
                        letters_left -= 1
                        revealed_count += 1
        
        game.update({
            'phase': 'play',
            'word': word,
            'clue': clue,
            'display': display,
            'letters_left': letters_left,
            'guessed': set()
        })

        # Create game start embed
        embed = Embed(title=f"{START} Hangman Dimulai!", color=0x2ecc71)
        embed.add_field(name="💡 Petunjuk", value=f"`{clue}`", inline=False)
        
        if revealed_count > 0:
            embed.add_field(
                name="🎁 Bonus", 
                value=f"Diberikan {revealed_count} huruf sebagai bantuan!", 
                inline=False
            )
        
        embed.add_field(
            name=f"{CHAT} Kata", 
            value=f"```{' '.join(display)}```", 
            inline=False
        )
        
        # Player info
        players_info = []
        for p in game['players'].values():
            health_display = f"{REDHEART}" * p['health']
            players_info.append(f"• **{p['member'].display_name}** | {health_display} | {POINT} {p['points']}")
        
        embed.add_field(name=f"{DICE} Pemain", value="\n".join(players_info), inline=False)
        
        game_mode = f"{DICE} **Solo Mode**" if is_solo else f"⚔️ **Multiplayer Mode** ({len(game['players'])} pemain)"
        embed.add_field(name=f"{POINT} Mode Game", value=game_mode, inline=False)
        
        embed.set_footer(text="💭 Ketik 1 huruf untuk menebak huruf, atau ketik kata lengkap untuk menebak seluruh kata!")
        await ctx.send(embed=embed)

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
            
        cid = message.channel.id
        game = self.games.get(cid)
        
        # Skip if no active game or not in play phase
        if not game or game.get('phase') != 'play':
            return

        content = message.content.strip().lower()
        player = game['players'].get(message.author.id)
        
        # Skip if not a registered player
        if not player:
            return

        # Validate input
        if not content or not content.replace(' ', '').isalpha():
            return

        # Handle word guess (more than 1 character)
        if len(content.replace(' ', '')) > 1:
            if content == game['word']:
                player['points'] += 3
                player['correct_guesses'] += 1
                await message.add_reaction(f"{PRIZE}")
                
                success_msg = (
                    f"✨ **{message.author.display_name}** menebak kata dengan benar! "
                    f"{POINT} **+3 poin!** Total: **{player['points']}** poin"
                )
                await message.channel.send(success_msg)
                
                # End game logic
                if game['is_solo']:
                    # Solo game ends immediately when word is guessed
                    await self._end_game(message.channel, game, reason="word_guessed")
                else:
                    # Multiplayer: continue until only one player remains
                    await self._end_game(message.channel, game, reason="word_guessed")
            else:
                player['health'] -= 1
                await message.add_reaction(f"{WRONG}")
                
                wrong_msg = (
                    f"{WRONG} **{message.author.display_name}** salah menebak kata!\n"
                    f"{SKULLHEART} Sisa nyawa: **{player['health']}/5**"
                )
                await message.channel.send(wrong_msg)
                await self._check_player_elimination(message.channel, message.author.id, game)
            return

        # Handle single letter guess
        if len(content) == 1 and content.isalpha():
            letter = content
            
            if letter in game['guessed']:
                await message.channel.send(
                    f"{WARNING} **{message.author.display_name}**, huruf `{letter.upper()}` sudah pernah ditebak!", 
                    delete_after=5
                )
                return
                
            game['guessed'].add(letter)
            
            if letter in game['word']:
                # Update display for correct guess
                correct_positions = []
                for idx, char in enumerate(game['word']):
                    if char == letter and game['display'][idx] == '_':
                        game['display'][idx] = letter
                        correct_positions.append(idx + 1)
                
                if correct_positions:
                    player['points'] += 1
                    player['correct_guesses'] += 1
                    await message.add_reaction(f"{CORRECT}")
                    
                    correct_msg = (
                        f"{CORRECT} **{message.author.display_name}** benar! "
                        f"{POINT} **+1 poin!** Total: **{player['points']}** poin"
                    )
                    await message.channel.send(correct_msg)
                    
                    # Check if word is completed
                    if '_' not in ''.join(game['display']):
                        completion_msg = f"{PRIZE} **Selamat! Semua huruf berhasil ditebak!**"
                        await message.channel.send(completion_msg)
                        
                        if game['is_solo']:
                            await self._end_game(message.channel, game, reason="word_completed")
                        else:
                            await self._end_game(message.channel, game, reason="word_completed")
                        return
                    
                    # Only update status after correct guess (as requested)
                    await self._update_game_status(message.channel, game)
            else:
                player['health'] -= 1
                await message.add_reaction(f"{WRONG}")
                
                wrong_msg = (
                    f"{WRONG} **{message.author.display_name}** salah! Huruf `{letter.upper()}` tidak ada. "
                    f"{SKULLHEART} Sisa nyawa: **{player['health']}/5**"
                )
                await message.channel.send(wrong_msg)
                await self._check_player_elimination(message.channel, message.author.id, game)

    async def _update_game_status(self, channel, game):
        """Update game status - only called after correct guesses"""
        embed = Embed(title=f"Status Game", color=0xf39c12)
        embed.add_field(name="💡 Petunjuk", value=f"`{game['clue']}`", inline=False)
        embed.add_field(name=f"{CHAT} Kata", value=f"```{' '.join(game['display'])}```", inline=False)
        
        # Player status
        players_info = []
        for player in game['players'].values():
            health_hearts = f"{REDHEART}" * player['health']
            health_broken = f"{SKULLHEART}" * (5 - player['health'])
            health_display = health_hearts + health_broken
            
            players_info.append(
                f"• **{player['member'].display_name}** | {health_display} | {POINT} {player['points']}"
            )
        
        embed.add_field(name=f"{SKULL} Status Pemain", value="\n".join(players_info), inline=False)
        
        # Guessed letters with better formatting
        if game['guessed']:
            guessed_sorted = sorted(list(game['guessed']))
            guessed_display = ' '.join([f"`{letter.upper()}`" for letter in guessed_sorted])
        else:
            guessed_display = "_Belum ada huruf yang ditebak_"
            
        embed.add_field(name="🔤 Huruf yang Sudah Ditebak", value=guessed_display, inline=False)
        
        # Progress info
        total_letters = len([c for c in game['word'] if c.isalpha()])
        revealed_letters = len([c for c in game['display'] if c.isalpha()])
        progress = f"{revealed_letters}/{total_letters} huruf terungkap"
        
        embed.add_field(name=f"{PROGRESS} Progress", value=progress, inline=True)
        
        game_mode = f"{DICE} Solo" if game['is_solo'] else f"⚔️ Multiplayer ({len(game['players'])})"
        embed.add_field(name=f"{START} Mode", value=game_mode, inline=True)
        
        embed.set_footer(text="💭 Terus tebak huruf atau langsung tebak kata!")
        await channel.send(embed=embed)

    async def _check_player_elimination(self, channel, user_id, game):
        """Check if player should be eliminated and handle game end conditions"""
        cid = channel.id
        player = game['players'].get(user_id)
        if not player:
            return
            
        if player['health'] <= 0:
            eliminated_player = game['players'][user_id]
            del game['players'][user_id]
            
            elimination_embed = Embed(
                title=f"{SKULL} Player Eliminated!",
                description=f"**{eliminated_player['member'].display_name}** kehabisan nyawa dan tereliminasi!",
                color=0xe74c3c
            )
            elimination_embed.add_field(
                name=f"{PLANNER} Statistik Final", 
                value=f"Poin: **{eliminated_player['points']}** | Tebakan Benar: **{eliminated_player['correct_guesses']}**",
                inline=False
            )
            await channel.send(embed=elimination_embed)
            
            remaining_players = len(game['players'])
            
            if remaining_players == 0:
                await channel.send(f"**Semua pemain telah tereliminasi!**")
                await self._end_game(channel, game, reason="all_eliminated")
            elif remaining_players == 1 and not game['is_solo']:
                last_player = list(game['players'].values())[0]
                await channel.send(f"{PRIZE} **{last_player['member'].display_name}** adalah pemain terakhir yang tersisa!")
                await self._end_game(channel, game, reason="last_survivor")
            
    async def _end_game(self, channel, game, reason="completed"):
        """End the game with appropriate message based on reason"""
        cid = channel.id
        if cid not in self.games:
            return

        # Create end game embed based on reason
        if reason == "word_guessed":
            if game['players']:
                # Find who guessed the word (highest points or most recent action)
                winner = max(game['players'].values(), key=lambda p: (p['points'], p['correct_guesses']))
                embed = Embed(
                    title=f"KATA BERHASIL DITEBAK!",
                    description=(
                        f"{PRIZE} **{winner['member'].mention}** memenangkan game!\n"
                        f"{POINT} **Poin**: {winner['points']}\n"
                        f"{CORRECT} **Tebakan Benar**: {winner['correct_guesses']}\n\n"
                        f"{CHAT} **Kata**: `{game['word'].upper()}`"
                    ),
                    color=0x2ecc71
                )
            else:
                embed = Embed(
                    title=f"{PRIZE} GAME SELESAI",
                    description=f"{CHAT} **Kata**: `{game['word'].upper()}`",
                    color=0x3498db
                )
        
        elif reason == "word_completed":
            if game['players']:
                winner = max(game['players'].values(), key=lambda p: (p['points'], p['correct_guesses']))
                embed = Embed(
                    title=f"{PRIZE} SEMUA HURUF TERKUAK!",
                    description=(
                        f"{PRIZE} **{winner['member'].mention}** memenangkan game!\n"
                        f"{POINT} **Poin**: {winner['points']}\n"
                        f"{CORRECT} **Tebakan Benar**: {winner['correct_guesses']}\n\n"
                        f"{CHAT} **Kata**: `{game['word'].upper()}`"
                    ),
                    color=0x2ecc71
                )
            else:
                embed = Embed(
                    title=f"{PRIZE} SEMUA HURUF TERKUAK!",
                    description=f"{CHAT} **Kata**: `{game['word'].upper()}`",
                    color=0x3498db
                )
        
        elif reason == "last_survivor":
            winner = list(game['players'].values())[0]
            embed = Embed(
                title=f"{PRIZE} PEMENANG - SURVIVOR TERAKHIR!",
                description=(
                    f"{WINNER} **{winner['member'].mention}** bertahan hingga akhir!\n"
                    f"{POINT} **Poin**: {winner['points']}\n"
                    f"{CORRECT} **Tebakan Benar**: {winner['correct_guesses']}\n\n"
                    f"{CHAT} **Kata**: `{game['word'].upper()}`"
                ),
                color=0xf1c40f
            )
        
        elif reason == "all_eliminated":
            embed = Embed(
                title=f"{SKULL} GAME OVER",
                description=(
                    f"{SKULL} Semua pemain telah tereliminasi!\n\n"
                    f"{CHAT} **Kata yang benar**: `{game['word'].upper()}`"
                ),
                color=0xe74c3c
            )
        
        else:  # Default completion
            if game['players']:
                winner = max(game['players'].values(), key=lambda p: (p['points'], p['correct_guesses']))
                embed = Embed(
                    title=f"{PRIZE} PEMENANG!",
                    description=(
                        f"{PRIZE} **{winner['member'].mention}** memenangkan game!\n"
                        f"{POINT} **Poin**: {winner['points']}\n"
                        f"{CORRECT} **Tebakan Benar**: {winner['correct_guesses']}\n\n"
                        f"{CHAT} **Kata**: `{game['word'].upper()}`"
                    ),
                    color=0x2ecc71
                )
            else:
                embed = Embed(
                    title=f"{PRIZE} GAME SELESAI",
                    description=f"{CHAT} **Kata**: `{game['word'].upper()}`",
                    color=0x3498db
                )

        # Add final scoreboard if multiple players
        if len(game['players']) > 1:
            scoreboard = []
            sorted_players = sorted(game['players'].values(), key=lambda p: (p['points'], p['correct_guesses']), reverse=True)
            
            for i, player in enumerate(sorted_players, 1):
                medal = "🥇" if i == 1 else "🥈" if i == 2 else "🥉" if i == 3 else f"{i}."
                scoreboard.append(
                    f"{medal} **{player['member'].display_name}** - {player['points']} poin ({player['correct_guesses']} benar)"
                )
            
            embed.add_field(name="🏅 Scoreboard Final", value="\n".join(scoreboard), inline=False)

        # Add game statistics
        total_guesses = len(game['guessed'])
        embed.add_field(
            name=f"{PLANNER} Statistik Game", 
            value=f"Total huruf ditebak: {total_guesses}\nMode: {'Solo' if game['is_solo'] else 'Multiplayer'}", 
            inline=True
        )

        embed.set_footer(text="Terima kasih telah bermain! Ketik !hm untuk game baru.")
        await channel.send(embed=embed)

        # Cleanup
        del self.games[cid]

    @commands.command(name="hstop", aliases=["hangman_stop"])
    async def force_stop_game(self, ctx: commands.Context):
        """Force stop hangman game (only for host or admin)"""
        cid = ctx.channel.id
        game = self.games.get(cid)
        
        if not game:
            return await ctx.send("❗ Tidak ada game Hangman aktif di channel ini.")
        
        # Check permissions
        is_host = ctx.author == game['host']
        is_admin = ctx.author.guild_permissions.manage_messages
        
        if not (is_host or is_admin):
            return await ctx.send(f"{WARNING} Hanya host game atau admin yang dapat menghentikan game.")
        
        embed = Embed(
            title="⛔ Game Dihentikan",
            description=f"Game hangman dihentikan oleh {ctx.author.mention}.\n\n{CHAT} **Kata**: `{game['word'].upper()}`",
            color=0x95a5a6
        )
        
        await ctx.send(embed=embed)
        del self.games[cid]

async def setup(bot: commands.Bot):
    await bot.add_cog(HangmanCog(bot))